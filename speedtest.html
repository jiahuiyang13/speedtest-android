<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Speed Check</title>
  <style>
    body {
      font: 16px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #fafafa;
      color: #222;
    }
  </style>
</head>
<body>
  <div id="s">Running network speed testâ€¦</div>

  <script>
    /********* CONFIG *********/
    const COLLECTOR_URL = "https://script.google.com/macros/s/AKfycbwsdxYyIKa3QRzsrjUISq660hZaLxTLlDXwzjxNWL3l0wriqi3Mrfs7OjC4xTJl-saj3w/exec";
    const SECRET        = "secretkey"; // must match Apps Script
    /**************************/

    const WARMUP_BYTES = 8_000_000;
    const PROBE_BYTES  = 25_000_000;
    const WARMUP_TO    = 30; // seconds
    const PROBE_TO     = 45; // seconds
    const RUNS         = 3;  // measured runs

    // --- 1) Ensure each device has a stable ?device=ID in the URL ---
    (function ensureDeviceParam() {
      const url = new URL(location.href);
      const current = url.searchParams.get("device");

      const looksBad =
        !current ||
        current.includes("$") ||
        current.startsWith("Mozilla/") ||
        current === "Unknown";

      if (!looksBad) {
        // Already have a decent device ID, continue normally
        return;
      }

      const KEY = "speedtest_device_id_v1";
      let id = null;

      try {
        id = localStorage.getItem(KEY);
      } catch (e) {
        // ignore
      }

      if (!id) {
        id =
          "dev-" +
          Math.random().toString(36).slice(2, 8) + "-" +
          Date.now().toString(36).slice(-4);
        try {
          localStorage.setItem(KEY, id);
        } catch (e) {
          // if localStorage fails, we still use this id (non-persistent)
        }
      }

      url.searchParams.set("device", id);

      // Reload once with the new device ID in the URL
      location.replace(url.toString());
    })();

    // --- 2) Main flow ---
    main().catch(e => finish(false, "err:" + (e && e.message || e)));

    function zonedISO(tz = "America/Chicago") {
      const now = new Date();
      const parts = new Intl.DateTimeFormat("en-CA", {
        timeZone: tz,
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit", second: "2-digit",
        hourCycle: "h23"
      }).formatToParts(now).reduce((a, p) => {
        a[p.type] = p.value;
        return a;
      }, {});
      const yyyy = parts.year, MM = parts.month, dd = parts.day;
      const HH = parts.hour, mm = parts.minute, ss = parts.second;

      const inDST = new Intl.DateTimeFormat("en-US", {
        timeZone: tz,
        timeZoneName: "short"
      }).format(now).includes("CDT");
      const tzAbbr = inDST ? "CDT" : "CST";

      return `${yyyy}-${MM}-${dd} ${HH}:${mm}:${ss} ${tzAbbr}`;
    }

    async function main() {
      const device    = getDeviceFromQuery();       // now guaranteed stable per device
      const timestamp = zonedISO("America/Chicago");
      const userAgent = navigator.userAgent || "";

      let public_ip = "";
      try {
        const r = await fetch("https://api.ipify.org?format=json", { cache: "no-store" });
        public_ip = (await r.json()).ip || "";
      } catch (e) {}

      // Warmup (ignore result)
      try { await httpProbe(WARMUP_BYTES, WARMUP_TO); } catch (e) {}

      // Measured runs
      const runs = [];
      for (let i = 0; i < RUNS; i++) {
        try {
          const v = await httpProbe(PROBE_BYTES, PROBE_TO);
          if (Number.isFinite(v)) runs.push(v);
        } catch (e) {}
      }

      const mbps = median(runs);
      const download_mbps = Number.isFinite(mbps)
        ? Math.round(mbps * 100) / 100
        : null;

      const payload = {
        secret: SECRET,
        timestamp,
        device,
        public_ip,
        user_agent: userAgent,
        download_mbps
      };

      const ok = await postOrGetFallback(COLLECTOR_URL, payload);

      let msg;
      if (ok) {
        msg = download_mbps != null
          ? `OK ${download_mbps} Mbps`
          : "OK (no result)";
      } else {
        msg = "Upload failed";
      }

      finish(ok, msg);
    }

    function getDeviceFromQuery() {
      const url = new URL(location.href);
      const dev = url.searchParams.get("device") || "";
      return dev.substring(0, 128);
    }

    function finish(ok, msg) {
      document.getElementById("s").textContent =
        msg || (ok ? "Done" : "Failed");
      setTimeout(() => { try { window.close(); } catch (e) {} }, 1200);
    }

    async function httpProbe(bytes, timeoutSec) {
      const url = `https://speed.cloudflare.com/__down?bytes=${bytes}&nonce=${Math.random().toString(36).slice(2)}`;
      const ctrl = new AbortController();
      const tid  = setTimeout(() => ctrl.abort(), timeoutSec * 1000);

      const t0 = performance.now();
      const res = await fetch(url, { signal: ctrl.signal, cache: "no-store" });

      if (!res.body || !res.body.getReader) {
        clearTimeout(tid);
        throw new Error("ReadableStream not supported");
      }

      const reader = res.body.getReader();
      let total = 0;
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        total += value.byteLength;
      }
      clearTimeout(tid);

      const sec = (performance.now() - t0) / 1000;
      if (sec <= 0) throw new Error("zero time");
      return (total * 8 / 1e6) / sec;
    }

    function median(arr) {
      if (!arr || !arr.length) return NaN;
      const s = arr.slice().sort((a, b) => a - b);
      const m = Math.floor(s.length / 2);
      return s.length % 2 ? s[m] : (s[m - 1] + s[m]) / 2;
    }

    async function postOrGetFallback(url, body) {
      // Try POST JSON
      try {
        const r = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        const t = await r.text();
        if (r.ok && !/^Forbidden|^ERR:/i.test(t)) return true;
      } catch (e) {}

      // Fallback GET
      const q = new URLSearchParams({
        secret: body.secret,
        device: body.device || "",
        timestamp: body.timestamp || "",
        public_ip: body.public_ip || "",
        user_agent: body.user_agent || "",
        download_mbps: body.download_mbps != null
          ? String(body.download_mbps)
          : ""
      });

      try {
        const g = await fetch(
          url + (url.includes("?") ? "&" : "?") + q.toString(),
          { method: "GET" }
        );
        const tt = await g.text();
        return g.ok && !/^Forbidden|^ERR:/i.test(tt);
      } catch (e) {
        return false;
      }
    }
  </script>
</body>
</html>
